# File: rand_mat.jl
# Author: Bastien Vieublé
# Email: bastien.vieuble@amss.ac.cn
# Github: https://github.com/bvieuble

"""
```julia
struct Preconditioner
    Mx  ::Function   # Function forming M * vector
    AMx ::Function   # Function forming A * M * vector
    MAx ::Function   # Function forming M * A * vector
    MA  ::Function   # Function computing M * A (useful in do_stats mode)
    AM  ::Function   # Function computing A * M (useful in do_stats mode)
    M   ::Function   # Function forming explicitely M^(-1) (useful in do_stats \
                       mode)
end
```
A structure that describes the preconditioner interface of this package. Each
preconditioner has to be wrapped in this structure to be used by
[`xgmres`](@ref). In particular, the `Preconditioner.Mx` function
implements the application of the preconditioner to a vector. The
`Preconditioner.AMx` implements the right-preconditioned product \$A \\times M \\times v\$
used when [`xgmres`](@ref) is set in right-preconditioning mode
(`kind="right"`). Conversely, the `Preconditioner.MAx` implements the
left-preconditioned product \$M \\times A \\times v\$ used when [`xgmres`](@ref) is set in
left-preconditioning mode (`kind="left"`).

"""
struct Preconditioner
    Mx  ::Function
    AMx ::Function
    MAx ::Function
    MA  ::Function
    AM  ::Function
    M   ::Function
end

"""
```julia
precond::Preconditioner = create_precond_I(
    A  ::AbstractMatrix{T},  # Matrix A
    uₐ ::DataType            # Precision at which the matrix A is applied
) where {T<:AbstractFloat}
```
Identity preconditioner. It allows to run the mixed precision GMRES algorithm
[`xgmres`](@ref) without preconditioners.

!!! note "Use case"
    The function [`xgmres`](@ref) requires a `precond` parameter. When this
    parameter is not provided, the function intializes `precond` as an
    identity preconditioner generated by this function.
"""
function create_precond_I(
        A::AbstractMatrix{T},
        uₐ::DataType
    ) where {T<:AbstractFloat}

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return x, dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true)
        else
            dict = Dict();
        end
        return Aₐ * xconvert(uₐ, x), xconvert(uₐ, x), dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true)
        else
            dict = Dict();
        end
        return Aₐ * xconvert(uₐ, x), dict;
    end

    MA = function ()
        return convert(Matrix{Float64}, A)
    end

    AM = function ()
        return convert(Matrix{Float64}, A)
    end

    M = function ()
        n = size(A)[1]
        return Matrix(Float64(1.0)I, n, n)
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_ilu(
    A  ::AbstractSparseMatrix{Tv,Ti},  # Matrix A
    τ  ::Float64,  # Parameter of ILU quantifying the accuracy of the \
                     incomplete factorization
    uₓ ::DataType, # Precision at which the ILU factorization is computed
    uₐ ::DataType, # Precision at which the matrix A is applied
    uₘ ::DataType  # Precision at which M^{-1} is applied
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Threshold incomplete LU preconditioner. It is a wrapper of the
[IncompleteLU.jl](https://github.com/haampie/IncompleteLU.jl) package.

!!! warning "Symmetric matrices not allowed"
    The ILU preconditioner cannot be applied on Julia sparse symmetric
    matrices. The underlying reason being that there are better preconditioners
    dedicated to the symmetric case (e.g., Incomplete Cholesky). However, as
    the symmetric equivalent of the threshold ILU package we use does not
    exist, for convernience, we also use the ILU preconditioner on symmetric
    problems by unsymmetrizing the input matrix.
"""
function create_precond_ilu(
        A   ::AbstractSparseMatrix{Tv,Ti},
        τ   ::Float64,
        uₓ  ::DataType,
        uₐ  ::DataType,
        uₘ  ::DataType
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (typeof(A) == Symmetric{eltype(A),SparseMatrixCSC{eltype(A),Int64}})
        Aₓ = convert(SparseMatrixCSC{uₓ,Int64}, A)
    elseif (eltype(A) != uₓ)
        Aₓ = xconvert(uₓ, A)
    else
        Aₓ = A
    end

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    ILUₓ = ilu(Aₓ, τ=τ*norm(Aₓ, 1))
    ILUₘ = xconvert(uₘ, ILUₓ)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILUₘ \ xconvert(uₘ, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, ILUₘ \ xconvert(uₘ, x));
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILUₘ \ xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        n    = size(A)[1]
        MAₑ  = zeros(Float64, n, n)
        ILUₑ = xconvert(Float64, ILUₘ)
        Aₑ   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            MAₑ[:, k] = ILUₑ \ Aₑ[:, k]
        end
        return MAₑ
        # return ILUm.U' \ (ILUm.L + I) \ xconvert(um, A);
    end

    AM = function ()
        n    = size(A)[1]
        AMₑ  = zeros(Float64, n, n)
        Iₑ   = Matrix(Float64(1.0)I, n, n)
        ILUₑ = xconvert(Float64, ILUₘ)
        Aₑ   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            AMₑ[:, k] = ILUₑ \ Iₑ[:, k]
        end
        AMₑ = Aₑ * AMₑ
        return AMₑ
    end

    M = function ()
        n    = size(A)[1]
        Mₑ   = zeros(Float64, n, n)
        Iₑ   = Matrix(Float64(1.0)I, n, n)
        ILUₑ = xconvert(Float64, ILUₘ)
        for k = 1:size(A)[1]
            Mₑ[:, k] = ILUₑ \ Iₑ[:, k]
        end
        return Mₑ
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_lu(
    A   ::AbstractMatrix{T},  # Matrix A
    uₓ  ::DataType,           # Precision at which the LU factorization is \
                                computed
    uₐ  ::DataType,           # Precision at which the matrix A is applied
    uₘ  ::DataType            # Precision at which M^{-1} is applied
) where {T<:AbstractFloat}
```
LU preconditioner using the builtin Julia LU factorization
[`LinearAlgebra.lu`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/\
#LinearAlgebra.lu).

!!! warning "Sparse matrices not allowed"
    The sparse Julia LU factorization calls UMFPACK, which only supports
    Float64 arithmetic. For this reason we densify the matrix when using this
    preconditioner when the input is sparse.
"""
function create_precond_lu(
        A  ::AbstractMatrix{T},
        uₓ ::DataType,
        uₐ ::DataType,
        uₘ ::DataType
    ) where {T<:AbstractFloat}

    if (typeof(A) != Matrix{eltype(A)})
        Aₓ = convert(Matrix{uₓ}, A)
    elseif (eltype(A) != uₓ)
        Aₓ = xconvert(uₓ, A)
    else
        Aₓ = A
    end

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    LUₓ = lu(Aₓ)
    LUₘ = xconvert(uₘ, LUₓ)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return LUₘ \ xconvert(uₘ, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, LUₘ \ xconvert(uₘ, x))
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return LUₘ \ xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MAₑ = zeros(Float64, n, n)
        Aₑ  = xconvert(Float64, A)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            MAₑ[:, k] = LUₑ \ Aₑ[:, k]
        end
        return MAₑ
    end

    AM = function ()
        n   = size(A)[1]
        AMₑ = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        Aₑ  = xconvert(Float64, A)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            AMₑ[:, k] = LUₑ \ Iₑ[:, k]
        end
        AMₑ = Aₑ * AMₑ
        return AMₑ
    end

    M = function ()
        n   = size(A)[1]
        Mₑ  = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        LUₑ = xconvert(Float64, LUₘ)
        for k = 1:size(A)[1]
            Mₑ[:, k] = LUₑ \ Iₑ[:, k]
        end
        return Mₑ
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_amg(
    A  ::AbstractSparseMatrix{Tv,Ti}, # Matrix A
    uₓ ::DataType,  # Precision at which the AMG preconditioner is computed
    uₐ ::DataType,  # Precision at which the matrix A is applied
    uₘ ::DataType   # Precision at which the AMG preconditioner is applied
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Algebraic Multigrid preconditioner. It is a wrapper of the
[AlgebraicMutligrid.jl](https://github.com/JuliaLinearAlgebra/\
AlgebraicMultigrid.jl) package.

!!! note "Sparse only"
    By construction the AMG preconditioner can only be applied to sparse
    matrices.
"""
function create_precond_amg(
        A  ::AbstractSparseMatrix{Tv,Ti},
        uₓ ::DataType,
        uₐ ::DataType,
        uₘ ::DataType
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (eltype(A) != uₓ)
        Aₓ = xconvert(uₓ, A)
    else
        Aₓ = A
    end

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    AMGₓ     = ruge_stuben(Aₓ)
    AMGₘ     = xconvert(uₘ, AMGₓ)
    precondₘ = aspreconditioner(AMGₘ)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return precondₘ \ xconvert(uₘ, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, precondₘ \ xconvert(uₘ, x));
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return precondₘ \ xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MAₑ = zeros(Float64, n, n)
        Aₑ  = xconvert(Float64, A)
        pₑ  = aspreconditioner(xconvert(Float64, AMGₘ))
        for k = 1:size(A)[1]
            MAₑ[:, k] = pₑ \ Aₑ[:, k]
        end
        return MAₑ
    end

    AM = function ()
        n   = size(A)[1]
        AMₑ = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        Aₑ  = xconvert(Float64, A)
        pₑ  = aspreconditioner(xconvert(Float64, AMGₘ))
        for k = 1:size(A)[1]
            AMₑ[:, k] = pₑ \ Iₑ[:, k]
        end
        AMₑ = Aₑ * AMₑ
        return AMₑ
    end

    M = function ()
        n  = size(A)[1]
        Mₑ = zeros(Float64, n, n)
        Iₑ = Matrix(Float64(1.0)I, n, n)
        pₑ = aspreconditioner(xconvert(Float64, AMGₘ))
        for k = 1:size(A)[1]
            Mₑ[:, k] = pₑ \ Iₑ[:, k]
        end
        return Mₑ
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_spai(
    A     ::Union{AbstractSparseMatrix{Tv,Ti},
                  Symmetric{Tv,SparseMatrixCSC{T,Ti}}}, # Matrix A
    uₓ    ::DataType,          # Precision at which the SPAI preconditioner \
                                 is computed
    uₐ    ::DataType,          # Precision at which the matrix A is applied
    uₘ    ::DataType;          # Precision at which M^{-1} is applied
    kind  ::String  = "left",  # Kind of preconditioning: 'left', 'right', or \
                                 'flexible'
    ϵ     ::Float64 = 0.3,     # Accuracy of the approximation
    β     ::Integer = 8,       # Maximum number of nnz to add in a column \
                                 after one refinement
    α     ::Integer = round(Int64, size(A)[1] / β, RoundUp)  # Maximum number \
                of time we refine a column
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Sparse approximate inverse preconditioner calling the function [`spai`](@ref)
provided in this package.

!!! warning "Sparse with full diagonal only"
    The SPAI preconditioner can only be applied to sparse systems. For now, the
    initial sparsity pattern of the SPAI preconditioner implemented in this
    package is set to be the identity. Therefore, any matrix with zeroes on the
    diagonal can fail.

!!! note "Left and right preconditioner"
    Depending on if left or right preconditioning is used, the
    preconditioner itself is not computed in the same way.
"""
function create_precond_spai(
        A     ::Union{AbstractSparseMatrix{Tv,Ti},
                      Symmetric{Tv,SparseMatrixCSC{Tv,Ti}}},
        uₓ    ::DataType,
        uₐ    ::DataType,
        uₘ    ::DataType;
        kind  ::String    = "left",
        ϵ     ::Float64   = 0.3,
        β     ::Integer   = 8,
        α     ::Integer   = round(Int64, size(A)[1] / β, RoundUp)
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (typeof(A) != SparseMatrixCSC{eltype(A),Int64})
        Aₓ = convert(SparseMatrixCSC{uₓ,Int64}, A)
    elseif (eltype(A) != uₓ)
        Aₓ = xconvert(uₓ, A)
    else
        Aₓ = A
    end

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    if kind == "left"
        Mₓ = SparseMatrixCSC(spai(Aₓ', ϵ, α, β)')
        Mₘ = xconvert(uₘ, Mₓ)
    elseif kind == "right" || kind == "flexible"
        Mₓ = spai(Aₓ, ϵ, α, β)
        Mₘ = xconvert(uₘ, Mₓ)
    else
        error("Wrong argument 'kind' for generating the SPAI preconditioner.")
    end


    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return Mₘ * xconvert(uₘ, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, Mₘ * xconvert(uₘ, x));
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return Mₘ * xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        return xconvert(Float64, Mₘ) * xconvert(Float64, A)
    end

    AM = function ()
        return xconvert(Float64, A) * xconvert(Float64, Mₘ)
    end

    M = function ()
        return xconvert(Float64, Mₘ)
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_poly(
    A   ::AbstractMatrix{TA},  # Matrix A
    b   ::Vector{TB},  # Right-hand side b
    uₓ  ::DataType,    # Precision at which the polynomial preconditioner \
                         is computed
    uₐ  ::DataType,    # Precision at which the matrix A is applied
    uₘ  ::DataType;    # Precision at which the polynomial preconditioner is \
                         applied
    deg ::Integer = 20 # Degree of the polynomial to generate
) where {TA<:AbstractFloat,TB<:AbstractFloat}
```
Polynomial preconditioner based on Arnoldi iterations calling the function
[`polynomial`](@ref) provided in this package.

!!! note "Right-hand side"
    To initialize the polynomial preconditioner, the right-hand side of
    the system needs to be provided.
"""
function create_precond_poly(
        A   ::AbstractMatrix{TA},
        b   ::Vector{TB},
        uₓ  ::DataType,
        uₐ  ::DataType,
        uₘ  ::DataType;
        deg ::Integer=20
    ) where {TA<:AbstractFloat,TB<:AbstractFloat}

    if (eltype(A) != uₓ)
        Aₓ = xconvert(uₓ, A)
    else
        Aₓ = A
    end

    if (eltype(b) != uₓ)
        bₓ = xconvert(uₓ, b)
    else
        bₓ = b
    end

    if (eltype(A) != uₐ)
        Aₐ = xconvert(uₐ, A)
    else
        Aₐ = A
    end

    𝑃ₓ = polynomial(Aₓ, bₓ, deg)
    # Aₓ is only used to compute the polynomial. Since it does not make sense
    # to use a lower precision A to apply the polynomial, we provide the
    # original matrix A to the polynomial structure.
    # 𝑃ₓ  = Poly(\)
    # 𝑃ₓ.A = A
    𝑃ₘ = xconvert(uₘ, Poly(A, 𝑃ₓ.H, 𝑃ₓ.g, 𝑃ₓ.deg))

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return 𝑃ₘ * xconvert(uₘ, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        zₐ = xconvert(uₐ, 𝑃ₘ * xconvert(uₘ, x));
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return 𝑃ₘ * xconvert(uₘ, Aₐ * xconvert(uₐ, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MAₑ = zeros(Float64, n, n)
        Aₑ  = xconvert(Float64, A)
        𝑃ₑ  = xconvert(Float64, 𝑃ₘ)
        for k = 1:size(A)[1]
            MAₑ[:, k] = 𝑃ₑ * Aₑ[:, k]
        end
        return MAₑ
    end

    AM = function ()
        n   = size(A)[1]
        AMₑ = zeros(Float64, n, n)
        Iₑ  = Matrix(Float64(1.0)I, n, n)
        Aₑ  = xconvert(Float64, A)
        𝑃ₑ  = xconvert(Float64, 𝑃ₘ)
        for k = 1:size(A)[1]
            AMₑ[:, k] = 𝑃ₑ * Iₑ[:, k]
        end
        AMₑ = Aₑ * AMₑ
        return AMₑ
    end

    M = function ()
        n  = size(A)[1]
        Mₑ = zeros(Float64, n, n)
        Iₑ = Matrix(Float64(1.0)I, n, n)
        𝑃ₑ = xconvert(Float64, 𝑃ₘ)
        for k = 1:size(A)[1]
            Mₑ[:, k] = 𝑃ₑ * Iₑ[:, k]
        end
        return Mₑ
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_mumps(
    A   ::AbstractMatrix{T},  # Matrix A
    uₓ  ::DataType,           # Precision at which the LU factorization is \
                                computed
    uₐ  ::DataType,           # Precision at which the matrix A is applied
) where {T<:AbstractFloat}
```
MUMPS preconditioner using MUMPS.
"""
function create_precond_mumps(
        A  ::AbstractMatrix{T},
        uₓ ::DataType,
        uₐ ::DataType
    ) where {T<:AbstractFloat}

    if (eltype(A) != uₓ)
        Aₓ = convert(SparseMatrixCSC{uₓ, Int}, A)
    else
        Aₓ = A
    end

    if (eltype(A) != uₐ)
        Aₐ = convert(SparseMatrixCSC{uₐ, Int}, A)
    else
        Aₐ = A
    end

    MPI.Init()
    mumps = Mumps{uₓ}(mumps_unsymmetric, default_icntl, default_cntl64)
    MUMPS.set_icntl!(mumps,4,0)
    associate_matrix!(mumps, A)
    factorize!(mumps)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        MUMPS.set_job!(mumps,2)
        associate_rhs!(mumps, x)
        MUMPS.solve!(mumps)
        z = get_solution(mumps)
        return z, dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        MUMPS.set_job!(mumps,2)
        associate_rhs!(mumps, x)
        MUMPS.solve!(mumps)
        z = get_solution(mumps)
        zₐ = xconvert(uₐ, z)
        return Aₐ * zₐ, zₐ, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        xₐ = Aₐ * xconvert(uₐ, x)
        x = xconvert(uₓ, xₐ)
        MUMPS.set_job!(mumps,2)
        associate_rhs!(mumps, x)
        MUMPS.solve!(mumps)
        z = get_solution(mumps)
        return z, dict;
    end

    MA = function ()
        n = size(A)[1]
        return speye(n);
    end

    AM = function ()
        n = size(A)[1]
        return speye(n);
    end

    M = function ()
        n = size(A)[1]
        return speye(n);
    end

    # finalize(mumps)
    # MPI.Finalize()

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end