# File: rand_mat.jl
# Author: Bastien Vieubl√©
# Email: bastien.vieuble@amss.ac.cn
# Github: https://github.com/bvieuble

"""
```julia
struct Preconditioner
    Mx  ::Function   # Function forming M * vector
    AMx ::Function   # Function forming A * M * vector
    MAx ::Function   # Function forming M * A * vector
    MA  ::Function   # Function computing M * A (useful in do_stats mode)
    AM  ::Function   # Function computing A * M (useful in do_stats mode)
    M   ::Function   # Function forming explicitely M^(-1) (useful in do_stats \
                     # mode)
end
```
A structure that describes the preconditioner interface of this package. Each 
preconditioner has to be wrapped in this structure to be used by 
[`xgmres`](@ref). In particular, the `Preconditioner.Mx` function 
implements the application of the preconditioner to a vector. The 
`Preconditioner.AMx` implements the right-preconditioned product \$A \\times M \\times v\$ 
used when [`xgmres`](@ref) is set in right-preconditioning mode 
(`kind="right"`). Conversely, the `Preconditioner.MAx` implements the 
left-preconditioned product \$M \\times A \\times v\$ used when [`xgmres`](@ref) is set in
left-preconditioning mode (`kind="left"`).

"""
struct Preconditioner
    Mx  ::Function
    AMx ::Function
    MAx ::Function
    MA  ::Function
    AM  ::Function
    M   ::Function
end

"""
```julia
precond::Preconditioner = create_precond_I(
    A  ::AbstractMatrix{T},  # Matrix A 
    u‚Çê ::DataType            # Precision at which the matrix A is applied
) where {T<:AbstractFloat}
```
Identity preconditioner. It allows to run the mixed precision GMRES algorithm 
[`xgmres`](@ref) without preconditioners.

!!! note "Use case"
    The function [`xgmres`](@ref) requires a `precond` parameter. When this 
    parameter is not provided, the function intializes `precond` as an 
    identity preconditioner generated by this function.
"""
function create_precond_I(
        A::AbstractMatrix{T}, 
        u‚Çê::DataType
    ) where {T<:AbstractFloat}

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return x, dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true)
        else
            dict = Dict();
        end
        return A‚Çê * xconvert(u‚Çê, x), xconvert(u‚Çê, x), dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true)
        else
            dict = Dict();
        end
        return A‚Çê * xconvert(u‚Çê, x), dict;
    end

    MA = function ()
        return convert(Matrix{Float64}, A)
    end

    AM = function ()
        return convert(Matrix{Float64}, A)
    end

    M = function ()
        n = size(A)[1]
        return Matrix(Float64(1.0)I, n, n)
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_ilu(
    A  ::AbstractSparseMatrix{Tv,Ti},  # Matrix A
    œÑ  ::Float64,  # Parameter of ILU quantifying the accuracy of the \
                     incomplete factorization
    u‚Çì ::DataType, # Precision at which the ILU factorization is computed
    u‚Çê ::DataType, # Precision at which the matrix A is applied
    u‚Çò ::DataType  # Precision at which M^{-1} is applied
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Threshold incomplete LU preconditioner. It is a wrapper of the 
[IncompleteLU.jl](https://github.com/haampie/IncompleteLU.jl) package. 

!!! warning "Symmetric matrices not allowed"
    The ILU preconditioner cannot be applied on Julia sparse symmetric 
    matrices. The underlying reason being that there are better preconditioners
    dedicated to the symmetric case (e.g., Incomplete Cholesky). However, as 
    the symmetric equivalent of the threshold ILU package we use does not 
    exist, for convernience, we also use the ILU preconditioner on symmetric 
    problems by unsymmetrizing the input matrix.
"""
function create_precond_ilu(
        A   ::AbstractSparseMatrix{Tv,Ti}, 
        œÑ   ::Float64, 
        u‚Çì  ::DataType, 
        u‚Çê  ::DataType, 
        u‚Çò  ::DataType
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (typeof(A) == Symmetric{eltype(A),SparseMatrixCSC{eltype(A),Int64}})
        A‚Çì = convert(SparseMatrixCSC{u‚Çì,Int64}, A)
    elseif (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    ILU‚Çì = ilu(A‚Çì, œÑ=œÑ*norm(A‚Çì, 1))
    ILU‚Çò = xconvert(u‚Çò, ILU‚Çì)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILU‚Çò \ xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, ILU‚Çò \ xconvert(u‚Çò, x));
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILU‚Çò \ xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        n    = size(A)[1]
        MA‚Çë  = zeros(Float64, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        A‚Çë   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            MA‚Çë[:, k] = ILU‚Çë \ A‚Çë[:, k]
        end
        return MA‚Çë
        # return ILUm.U' \ (ILUm.L + I) \ xconvert(um, A);
    end

    AM = function ()
        n    = size(A)[1]
        AM‚Çë  = zeros(Float64, n, n)
        I‚Çë   = Matrix(Float64(1.0)I, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        A‚Çë   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            AM‚Çë[:, k] = ILU‚Çë \ I‚Çë[:, k]
        end
        AM‚Çë = A‚Çë * AM‚Çë
        return AM‚Çë
    end

    M = function ()
        n    = size(A)[1]
        M‚Çë   = zeros(Float64, n, n)
        I‚Çë   = Matrix(Float64(1.0)I, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        for k = 1:size(A)[1]
            M‚Çë[:, k] = ILU‚Çë \ I‚Çë[:, k]
        end
        return M‚Çë
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

""" 
```julia
precond::Preconditioner = create_precond_lu(
    A   ::AbstractMatrix{T},  # Matrix A
    u‚Çì  ::DataType,           # Precision at which the LU factorization is \
                                computed
    u‚Çê  ::DataType,           # Precision at which the matrix A is applied
    u‚Çò  ::DataType            # Precision at which M^{-1} is applied
) where {T<:AbstractFloat}
```
LU preconditioner using the builtin Julia LU factorization 
[`LinearAlgebra.lu`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/\
#LinearAlgebra.lu).

!!! warning "Sparse matrices not allowed"
    The sparse Julia LU factorization calls UMFPACK, which only supports
    Float64 arithmetic. For this reason we densify the matrix when using this 
    preconditioner when the input is sparse.
"""
function create_precond_lu(
        A  ::AbstractMatrix{T},
        u‚Çì ::DataType,
        u‚Çê ::DataType,
        u‚Çò ::DataType
    ) where {T<:AbstractFloat}

    if (typeof(A) != Matrix{eltype(A)})
        A‚Çì = convert(Matrix{u‚Çì}, A)
    elseif (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    LU‚Çì = lu(A‚Çì)
    LU‚Çò = xconvert(u‚Çò, LU‚Çì)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return LU‚Çò \ xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, LU‚Çò \ xconvert(u‚Çò, x))
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return LU‚Çò \ xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MA‚Çë = zeros(Float64, n, n)
        A‚Çë  = xconvert(Float64, A)
        LU‚Çë = xconvert(Float64, LU‚Çò)
        for k = 1:size(A)[1]
            MA‚Çë[:, k] = LU‚Çë \ A‚Çë[:, k]
        end
        return MA‚Çë
    end

    AM = function ()
        n   = size(A)[1]
        AM‚Çë = zeros(Float64, n, n)
        I‚Çë  = Matrix(Float64(1.0)I, n, n)
        A‚Çë  = xconvert(Float64, A)
        LU‚Çë = xconvert(Float64, LU‚Çò)
        for k = 1:size(A)[1]
            AM‚Çë[:, k] = LU‚Çë \ I‚Çë[:, k]
        end
        AM‚Çë = A‚Çë * AM‚Çë
        return AM‚Çë
    end

    M = function ()
        n   = size(A)[1]
        M‚Çë  = zeros(Float64, n, n)
        I‚Çë  = Matrix(Float64(1.0)I, n, n)
        LU‚Çë = xconvert(Float64, LU‚Çò)
        for k = 1:size(A)[1]
            M‚Çë[:, k] = LU‚Çë \ I‚Çë[:, k]
        end
        return M‚Çë
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_amg(
    A  ::AbstractSparseMatrix{Tv,Ti}, # Matrix A
    u‚Çì ::DataType,  # Precision at which the AMG preconditioner is computed
    u‚Çê ::DataType,  # Precision at which the matrix A is applied
    u‚Çò ::DataType   # Precision at which the AMG preconditioner is applied
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Algebraic Multigrid preconditioner. It is a wrapper of the 
[AlgebraicMutligrid.jl](https://github.com/JuliaLinearAlgebra/\
AlgebraicMultigrid.jl) package.

!!! note "Sparse only"
    By construction the AMG preconditioner can only be applied to sparse 
    matrices.
"""
function create_precond_amg(
        A  ::AbstractSparseMatrix{Tv,Ti}, 
        u‚Çì ::DataType,
        u‚Çê ::DataType,
        u‚Çò ::DataType
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    AMG‚Çì     = ruge_stuben(A‚Çì)
    AMG‚Çò     = xconvert(u‚Çò, AMG‚Çì)
    precond‚Çò = aspreconditioner(AMG‚Çò)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return precond‚Çò \ xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, precond‚Çò \ xconvert(u‚Çò, x));
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return precond‚Çò \ xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MA‚Çë = zeros(Float64, n, n)
        A‚Çë  = xconvert(Float64, A)
        p‚Çë  = aspreconditioner(xconvert(Float64, AMG‚Çò))
        for k = 1:size(A)[1]
            MA‚Çë[:, k] = p‚Çë \ A‚Çë[:, k]
        end
        return MA‚Çë
    end

    AM = function ()
        n   = size(A)[1]
        AM‚Çë = zeros(Float64, n, n)
        I‚Çë  = Matrix(Float64(1.0)I, n, n)
        A‚Çë  = xconvert(Float64, A)
        p‚Çë  = aspreconditioner(xconvert(Float64, AMG‚Çò))
        for k = 1:size(A)[1]
            AM‚Çë[:, k] = p‚Çë \ I‚Çë[:, k]
        end
        AM‚Çë = A‚Çë * AM‚Çë
        return AM‚Çë
    end

    M = function ()
        n  = size(A)[1]
        M‚Çë = zeros(Float64, n, n)
        I‚Çë = Matrix(Float64(1.0)I, n, n)
        p‚Çë = aspreconditioner(xconvert(Float64, AMG‚Çò))
        for k = 1:size(A)[1]
            M‚Çë[:, k] = p‚Çë \ I‚Çë[:, k]
        end
        return M‚Çë
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_spai(
    A     ::Union{AbstractSparseMatrix{Tv,Ti},
                  Symmetric{Tv,SparseMatrixCSC{T,Ti}}}, # Matrix A
    u‚Çì    ::DataType,          # Precision at which the SPAI preconditioner \
                                 is computed
    u‚Çê    ::DataType,          # Precision at which the matrix A is applied
    u‚Çò    ::DataType;          # Precision at which M^{-1} is applied
    kind  ::String  = "left",  # Kind of preconditioning: 'left', 'right', or \
                                 'flexible'
    œµ     ::Float64 = 0.3,     # Accuracy of the approximation
    Œ≤     ::Integer = 8,       # Maximum number of nnz to add in a column \
                                 after one refinement
    Œ±     ::Integer = round(Int64, size(A)[1] / Œ≤, RoundUp)  # Maximum number \
                of time we refine a column
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Sparse approximate inverse preconditioner calling the function [`spai`](@ref) 
provided in this package.

!!! warning "Sparse with full diagonal only"
    The SPAI preconditioner can only be applied to sparse systems. For now, the
    initial sparsity pattern of the SPAI preconditioner implemented in this 
    package is set to be the identity. Therefore, any matrix with zeroes on the
    diagonal can fail.

!!! note "Left and right preconditioner"
    Note that depending on if left or right preconditioning is used, the 
    preconditioner itself is not computed in the same way.

!!! note "Default parameters"
    The default settings for Œ≤ and Œ± are the one advertised in the article 
    "Mixed Precision Iterative Refinement with Sparse Approximate Inverse 
    Preconditioning".
"""
function create_precond_spai(
        A     ::Union{AbstractSparseMatrix{Tv,Ti},
                      Symmetric{Tv,SparseMatrixCSC{Tv,Ti}}}, 
        u‚Çì    ::DataType, 
        u‚Çê    ::DataType, 
        u‚Çò    ::DataType; 
        kind  ::String    = "left", 
        œµ     ::Float64   = 0.3, 
        Œ≤     ::Integer   = 8,
        Œ±     ::Integer   = round(Int64, size(A)[1] / Œ≤, RoundUp)
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (typeof(A) != SparseMatrixCSC{eltype(A),Int64})
        A‚Çì = convert(SparseMatrixCSC{u‚Çì,Int64}, A)
    elseif (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    if kind == "left"
        M‚Çì = SparseMatrixCSC(spai(A‚Çì', œµ, Œ±, Œ≤)')
        M‚Çò = xconvert(u‚Çò, M‚Çì)
    elseif kind == "right" || kind == "flexible"
        M‚Çì = spai(A‚Çì, œµ, Œ±, Œ≤)
        M‚Çò = xconvert(u‚Çò, M‚Çì)
    else
        error("Wrong argument 'kind' for generating the SPAI preconditioner.")
    end


    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return M‚Çò * xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, M‚Çò * xconvert(u‚Çò, x));
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return M‚Çò * xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        return xconvert(Float64, M‚Çò) * xconvert(Float64, A)
    end

    AM = function ()
        return xconvert(Float64, A) * xconvert(Float64, M‚Çò)
    end

    M = function ()
        return xconvert(Float64, M‚Çò)
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end

"""
```julia
precond::Preconditioner = create_precond_poly(
    A   ::AbstractMatrix{TA},  # Matrix A
    b   ::Vector{TB},  # Right-hand side b
    u‚Çì  ::DataType,    # Precision at which the polynomial preconditioner \
                         is computed
    u‚Çê  ::DataType,    # Precision at which the matrix A is applied
    u‚Çò  ::DataType;    # Precision at which the polynomial preconditioner is \
                         applied
    deg ::Integer = 20 # Degree of the polynomial to generate
) where {TA<:AbstractFloat,TB<:AbstractFloat}
```
Polynomial preconditioner based on Arnoldi iterations calling the function 
[`polynomial`](@ref) provided in this package.

!!! note "Right-hand side"
    To initialize the polynomial preconditioner, the right-hand side of 
    the system needs to be provided.
"""
function create_precond_poly(
        A   ::AbstractMatrix{TA},
        b   ::Vector{TB},
        u‚Çì  ::DataType,
        u‚Çê  ::DataType,
        u‚Çò  ::DataType;
        deg ::Integer=20
    ) where {TA<:AbstractFloat,TB<:AbstractFloat}

    if (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(b) != u‚Çì)
        b‚Çì = xconvert(u‚Çì, b)
    else
        b‚Çì = b
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    ùëÉ‚Çì = polynomial(A‚Çì, b‚Çì, deg)
    # A‚Çì is only used to compute the polynomial. Since it does not make sense 
    # to use a lower precision A to apply the polynomial, we provide the
    # original matrix A to the polynomial structure.
    # ùëÉ‚Çì  = Poly(\)
    # ùëÉ‚Çì.A = A 
    ùëÉ‚Çò = xconvert(u‚Çò, Poly(A, ùëÉ‚Çì.H, ùëÉ‚Çì.g, ùëÉ‚Çì.deg))

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ùëÉ‚Çò * xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, ùëÉ‚Çò * xconvert(u‚Çò, x));
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ùëÉ‚Çò * xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        n   = size(A)[1]
        MA‚Çë = zeros(Float64, n, n)
        A‚Çë  = xconvert(Float64, A)
        ùëÉ‚Çë  = xconvert(Float64, ùëÉ‚Çò)
        for k = 1:size(A)[1]
            MA‚Çë[:, k] = ùëÉ‚Çë * A‚Çë[:, k]
        end
        return MA‚Çë
    end

    AM = function ()
        n   = size(A)[1]
        AM‚Çë = zeros(Float64, n, n)
        I‚Çë  = Matrix(Float64(1.0)I, n, n)
        A‚Çë  = xconvert(Float64, A)
        ùëÉ‚Çë  = xconvert(Float64, ùëÉ‚Çò)
        for k = 1:size(A)[1]
            AM‚Çë[:, k] = ùëÉ‚Çë * I‚Çë[:, k]
        end
        AM‚Çë = A‚Çë * AM‚Çë
        return AM‚Çë
    end

    M = function ()
        n  = size(A)[1]
        M‚Çë = zeros(Float64, n, n)
        I‚Çë = Matrix(Float64(1.0)I, n, n)
        ùëÉ‚Çë = xconvert(Float64, ùëÉ‚Çò)
        for k = 1:size(A)[1]
            M‚Çë[:, k] = ùëÉ‚Çë * I‚Çë[:, k]
        end
        return M‚Çë
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end









"""
```julia
precond::Preconditioner = create_precond_ilu0(
    A  ::AbstractSparseMatrix{Tv,Ti},  # Matrix A
    u‚Çì ::DataType, # Precision at which the ILU0 factorization is computed
    u‚Çê ::DataType, # Precision at which the matrix A is applied
    u‚Çò ::DataType  # Precision at which M^{-1} is applied
) where {Tv<:AbstractFloat,Ti<:Integer}
```
Incomplete LU preconditioner with zero fill-in. It is a wrapper of the 
[ILUZero.jl](https://github.com/mcovalt/ILUZero.jl) package. 
"""
function create_precond_ilu0(
        A   ::AbstractSparseMatrix{Tv,Ti}, 
        u‚Çì  ::DataType, 
        u‚Çê  ::DataType, 
        u‚Çò  ::DataType
    ) where {Tv<:AbstractFloat,Ti<:Integer}

    if (eltype(A) != u‚Çì)
        A‚Çì = xconvert(u‚Çì, A)
    else
        A‚Çì = A
    end

    if (eltype(A) != u‚Çê)
        A‚Çê = xconvert(u‚Çê, A)
    else
        A‚Çê = A
    end

    ILU‚Çì = ilu0(A‚Çì)
    ILU‚Çò = xconvert(u‚Çò, ILU‚Çì)

    Mx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILU‚Çò \ xconvert(u‚Çò, x), dict;
    end

    AMx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        z‚Çê = xconvert(u‚Çê, ILU‚Çò \ xconvert(u‚Çò, x));
        return A‚Çê * z‚Çê, z‚Çê, dict;
    end

    MAx = function (x, do_stats::Bool)
        if do_stats
            dict = Dict("do_stats" => true);
        else
            dict = Dict();
        end
        return ILU‚Çò \ xconvert(u‚Çò, A‚Çê * xconvert(u‚Çê, x)), dict;
    end

    MA = function ()
        n    = size(A)[1]
        MA‚Çë  = zeros(Float64, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        A‚Çë   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            MA‚Çë[:, k] = ILU‚Çë \ A‚Çë[:, k]
        end
        return MA‚Çë
        # return ILUm.U' \ (ILUm.L + I) \ xconvert(um, A);
    end

    AM = function ()
        n    = size(A)[1]
        AM‚Çë  = zeros(Float64, n, n)
        I‚Çë   = Matrix(Float64(1.0)I, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        A‚Çë   = xconvert(Float64, A)
        for k = 1:size(A)[1]
            AM‚Çë[:, k] = ILU‚Çë \ I‚Çë[:, k]
        end
        AM‚Çë = A‚Çë * AM‚Çë
        return AM‚Çë
    end

    M = function ()
        n    = size(A)[1]
        M‚Çë   = zeros(Float64, n, n)
        I‚Çë   = Matrix(Float64(1.0)I, n, n)
        ILU‚Çë = xconvert(Float64, ILU‚Çò)
        for k = 1:size(A)[1]
            M‚Çë[:, k] = ILU‚Çë \ I‚Çë[:, k]
        end
        return M‚Çë
    end

    return Preconditioner(Mx, AMx, MAx, MA, AM, M)
end
