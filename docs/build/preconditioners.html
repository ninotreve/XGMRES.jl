<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Preconditioners ¬∑ XGMRES.jl</title><meta name="title" content="Preconditioners ¬∑ XGMRES.jl"/><meta property="og:title" content="Preconditioners ¬∑ XGMRES.jl"/><meta property="twitter:title" content="Preconditioners ¬∑ XGMRES.jl"/><meta name="description" content="Documentation for XGMRES.jl."/><meta property="og:description" content="Documentation for XGMRES.jl."/><meta property="twitter:description" content="Documentation for XGMRES.jl."/><meta property="og:url" content="https://bvieuble.github.io/XGMRES.jl/preconditioners.html"/><meta property="twitter:url" content="https://bvieuble.github.io/XGMRES.jl/preconditioners.html"/><link rel="canonical" href="https://bvieuble.github.io/XGMRES.jl/preconditioners.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">XGMRES.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Overview</a></li><li><a class="tocitem" href="xgmres.html">XGMRES</a></li><li class="is-active"><a class="tocitem" href="preconditioners.html">Preconditioners</a><ul class="internal"><li><a class="tocitem" href="#List-of-available-preconditioners"><span>List of available preconditioners</span></a></li><li><a class="tocitem" href="#Sparse-approximate-inverse"><span>Sparse approximate inverse</span></a></li><li><a class="tocitem" href="#Polynomial-preconditioner"><span>Polynomial preconditioner</span></a></li></ul></li><li><a class="tocitem" href="auxiliary.html">Auxiliary Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="preconditioners.html">Preconditioners</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="preconditioners.html">Preconditioners</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bvieuble/XGMRES.jl/blob/main/docs/src/preconditioners.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Preconditioners"><a class="docs-heading-anchor" href="#Preconditioners">Preconditioners</a><a id="Preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioners" title="Permalink"></a></h1><p>The package wraps and implements various preconditioners. The complete list is given below:</p><table><tr><th style="text-align: left">Preconditioners</th><th style="text-align: left">Method</th><th style="text-align: left">Dense</th><th style="text-align: left">Sparse</th></tr><tr><td style="text-align: left">Identity</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_I"><code>create_precond_I</code></a></td><td style="text-align: left">‚úì</td><td style="text-align: left">‚úì</td></tr><tr><td style="text-align: left">LU</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_lu"><code>create_precond_lu</code></a></td><td style="text-align: left">‚úì</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">ILU</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_ilu"><code>create_precond_ilu</code></a></td><td style="text-align: left"></td><td style="text-align: left">‚úì</td></tr><tr><td style="text-align: left">AMG</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_amg"><code>create_precond_amg</code></a></td><td style="text-align: left"></td><td style="text-align: left">‚úì</td></tr><tr><td style="text-align: left">Polynomial</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_poly"><code>create_precond_poly</code></a></td><td style="text-align: left">‚úì</td><td style="text-align: left">‚úì</td></tr><tr><td style="text-align: left">SPAI</td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_spai"><code>create_precond_spai</code></a></td><td style="text-align: left"></td><td style="text-align: left">‚úì</td></tr><tr><td style="text-align: left">Random<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td><td style="text-align: left"><a href="preconditioners.html#XGMRES.create_precond_rand"><code>create_precond_rand</code></a></td><td style="text-align: left">‚úì</td><td style="text-align: left"></td></tr></table><p>To have a consistent interface to be used inside <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a>, the  preconditioners are wrapped in the following structure. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.Preconditioner" href="#XGMRES.Preconditioner"><code>XGMRES.Preconditioner</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Preconditioner
    Mx  ::Function   # Function forming M * vector
    AMx ::Function   # Function forming A * M * vector
    MAx ::Function   # Function forming M * A * vector
    MA  ::Function   # Function computing M * A (useful in do_stats mode)
    AM  ::Function   # Function computing A * M (useful in do_stats mode)
    M   ::Function   # Function forming explicitely M^(-1) (useful in do_stats # mode)
end</code></pre><p>A structure that describes the preconditioner interface of this package. Each  preconditioner has to be wrapped in this structure to be used by  <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a>. In particular, the <code>Preconditioner.Mx</code> function  implements the application of the preconditioner to a vector. The  <code>Preconditioner.AMx</code> implements the right-preconditioned product <span>$A \times M \times v$</span>  used when <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a> is set in right-preconditioning mode  (<code>kind=&quot;right&quot;</code>). Conversely, the <code>Preconditioner.MAx</code> implements the  left-preconditioned product <span>$M \times A \times v$</span> used when <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a> is set in left-preconditioning mode (<code>kind=&quot;left&quot;</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L6-L27">source</a></section></article><h2 id="List-of-available-preconditioners"><a class="docs-heading-anchor" href="#List-of-available-preconditioners">List of available preconditioners</a><a id="List-of-available-preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-available-preconditioners" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_I" href="#XGMRES.create_precond_I"><code>XGMRES.create_precond_I</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_I(
    A  ::AbstractMatrix{T},  # Matrix A 
    u‚Çê ::DataType            # Precision at which the matrix A is applied
) where {T&lt;:AbstractFloat}</code></pre><p>Identity preconditioner. It allows to run the mixed precision GMRES algorithm  <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a> without preconditioners.</p><div class="admonition is-info"><header class="admonition-header">Use case</header><div class="admonition-body"><p>The function <a href="xgmres.html#XGMRES.xgmres"><code>xgmres</code></a> requires a <code>precond</code> parameter. When this  parameter is not provided, the function intializes <code>precond</code> as an  identity preconditioner generated by this function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L38-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_lu" href="#XGMRES.create_precond_lu"><code>XGMRES.create_precond_lu</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_lu(
    A   ::AbstractMatrix{T},  # Matrix A
    u‚Çì  ::DataType,           # Precision at which the LU factorization is computed
    u‚Çê  ::DataType,           # Precision at which the matrix A is applied
    u‚Çò  ::DataType            # Precision at which M^{-1} is applied
) where {T&lt;:AbstractFloat}</code></pre><p>LU preconditioner using the builtin Julia LU factorization  <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.lu"><code>LinearAlgebra.lu</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Sparse matrices not allowed</header><div class="admonition-body"><p>The sparse Julia LU factorization calls UMFPACK, which only supports Float64 arithmetic. For this reason we densify the matrix when using this  preconditioner when the input is sparse.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L221-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_ilu" href="#XGMRES.create_precond_ilu"><code>XGMRES.create_precond_ilu</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_ilu(
    A  ::AbstractSparseMatrix{Tv,Ti},  # Matrix A
    œÑ  ::Float64,  # Parameter of ILU quantifying the accuracy of the incomplete factorization
    u‚Çì ::DataType, # Precision at which the ILU factorization is computed
    u‚Çê ::DataType, # Precision at which the matrix A is applied
    u‚Çò ::DataType  # Precision at which M^{-1} is applied
) where {Tv&lt;:AbstractFloat,Ti&lt;:Integer}</code></pre><p>Threshold incomplete LU preconditioner. It is a wrapper of the  <a href="https://github.com/haampie/IncompleteLU.jl">IncompleteLU.jl</a> package. </p><div class="admonition is-warning"><header class="admonition-header">Symmetric matrices not allowed</header><div class="admonition-body"><p>The ILU preconditioner cannot be applied on Julia sparse symmetric  matrices. The underlying reason being that there are better preconditioners dedicated to the symmetric case (e.g., Incomplete Cholesky). However, as  the symmetric equivalent of the threshold ILU package we use does not  exist, for convernience, we also use the ILU preconditioner on symmetric  problems by unsymmetrizing the input matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L107-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_amg" href="#XGMRES.create_precond_amg"><code>XGMRES.create_precond_amg</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_amg(
    A  ::AbstractSparseMatrix{Tv,Ti}, # Matrix A
    u‚Çì ::DataType,  # Precision at which the AMG preconditioner is computed
    u‚Çê ::DataType,  # Precision at which the matrix A is applied
    u‚Çò ::DataType   # Precision at which the AMG preconditioner is applied
) where {Tv&lt;:AbstractFloat,Ti&lt;:Integer}</code></pre><p>Algebraic Multigrid preconditioner. It is a wrapper of the  <a href="https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl">AlgebraicMutligrid.jl</a> package.</p><div class="admonition is-info"><header class="admonition-header">Sparse only</header><div class="admonition-body"><p>By construction the AMG preconditioner can only be applied to sparse  matrices.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L330-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_poly" href="#XGMRES.create_precond_poly"><code>XGMRES.create_precond_poly</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_poly(
    A   ::AbstractMatrix{TA},  # Matrix A
    b   ::Vector{TB},  # Right-hand side b
    u‚Çì  ::DataType,    # Precision at which the polynomial preconditioner is computed
    u‚Çê  ::DataType,    # Precision at which the matrix A is applied
    u‚Çò  ::DataType;    # Precision at which the polynomial preconditioner is applied
    deg ::Integer = 20 # Degree of the polynomial to generate
) where {TA&lt;:AbstractFloat,TB&lt;:AbstractFloat}</code></pre><p>Polynomial preconditioner based on Arnoldi iterations calling the function  <a href="preconditioners.html#XGMRES.polynomial"><code>polynomial</code></a> provided in this package.</p><div class="admonition is-info"><header class="admonition-header">Right-hand side</header><div class="admonition-body"><p>To initialize the polynomial preconditioner, the right-hand side of  the system needs to be provided.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L547-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_spai" href="#XGMRES.create_precond_spai"><code>XGMRES.create_precond_spai</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_spai(
    A     ::Union{AbstractSparseMatrix{Tv,Ti},
                  Symmetric{Tv,SparseMatrixCSC{T,Ti}}}, # Matrix A
    u‚Çì    ::DataType,          # Precision at which the SPAI preconditioner is computed
    u‚Çê    ::DataType,          # Precision at which the matrix A is applied
    u‚Çò    ::DataType;          # Precision at which M^{-1} is applied
    kind  ::String  = &quot;left&quot;,  # Kind of preconditioning: &#39;left&#39;, &#39;right&#39;, or &#39;flexible&#39;
    œµ     ::Float64 = 0.3,     # Accuracy of the approximation
    Œ≤     ::Integer = 8,       # Maximum number of nnz to add in a column after one refinement
    Œ±     ::Integer = round(Int64, size(A)[1] / Œ≤, RoundUp)  # Maximum number of time we refine a column
) where {Tv&lt;:AbstractFloat,Ti&lt;:Integer}</code></pre><p>Sparse approximate inverse preconditioner calling the function <a href="preconditioners.html#XGMRES.spai"><code>spai</code></a>  provided in this package.</p><div class="admonition is-warning"><header class="admonition-header">Sparse with full diagonal only</header><div class="admonition-body"><p>The SPAI preconditioner can only be applied to sparse systems. For now, the initial sparsity pattern of the SPAI preconditioner implemented in this  package is set to be the identity. Therefore, any matrix with zeroes on the diagonal can fail.</p></div></div><div class="admonition is-info"><header class="admonition-header">Left and right preconditioner</header><div class="admonition-body"><p>Depending on if left or right preconditioning is used, the preconditioner itself is not computed in the same way.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/preconditioner.jl#L436-L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.create_precond_rand" href="#XGMRES.create_precond_rand"><code>XGMRES.create_precond_rand</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond::Preconditioner = create_precond_rand(
    A   ::Matrix{TA},  # Matrix A 
    M   ::Matrix{TM},  # Preconditioner M of A
    u‚Çê  ::DataType,    # Precision at which the matrix A is applied
    u‚Çò  ::DataType     # Precision at which M^{-1} is applied
) where {TA&lt;:AbstractFloat,TM&lt;:AbstractFloat}</code></pre><p>Generate the <a href="preconditioners.html#XGMRES.Preconditioner"><code>Preconditioner</code></a> structure from random dense matrix A and  its associated preconditioner M generated by <a href="auxiliary.html#XGMRES.gen_mat_with_prec"><code>gen_mat_with_prec</code></a>. The  inverse of the preconditioner M is implicitely formed through computed exactly  its LU factors and applying substitutions algorithms in precision <span>$u_a$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/rand_mat.jl#L106-L119">source</a></section></article><h2 id="Sparse-approximate-inverse"><a class="docs-heading-anchor" href="#Sparse-approximate-inverse">Sparse approximate inverse</a><a id="Sparse-approximate-inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-approximate-inverse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.spai" href="#XGMRES.spai"><code>XGMRES.spai</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">M::SparseMatrixCSC{Tv,Ti} = spai(
    A ::Union{SparseMatrixCSC{Tv,Ti},Adjoint{Tv,SparseMatrixCSC{Tv,Ti}}},  # Sparse matrix A we compute the SPAI of 
    œµ ::Float64,  # Accuracy of the approximation
    Œ± ::Integer,  # Maximum number of time we refine a column 
    Œ≤ ::Integer   # Maximum number of nnz to add in a column after one refinement
) where {Tv&lt;:AbstractFloat,Ti&lt;:Integer} </code></pre><p>Computation of Sparse Approximate Inverse preconditioner (SPAI) of a given  sparse matrix A. This implementation is a Julia rewrite of the Matlab code of this  <a href="https://github.com/Noaman67khan/SPAI-GMRES-IR">github repo</a>, which is itself the companion code of the article <em>&quot;Mixed Precision Iterative Refinement with Sparse Approximate Inverse Preconditioning&quot;</em><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>In more detail, the function implement the following algorithm from<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. Note  however that, in our implementation, the initial sparsity pattern  <span>$\mathcal{J}$</span> is set to be always the identity.</p><p><img src="assets/spai.png" alt="spai_img"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/spai.jl#L6-L30">source</a></section></article><h2 id="Polynomial-preconditioner"><a class="docs-heading-anchor" href="#Polynomial-preconditioner">Polynomial preconditioner</a><a id="Polynomial-preconditioner-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-preconditioner" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.Poly" href="#XGMRES.Poly"><code>XGMRES.Poly</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Poly{TA&lt;:AbstractFloat,TP&lt;:AbstractFloat}
    A    ::AbstractMatrix{TA}  # The matrix A 
    H    ::Matrix{TP}  # The Arnoldi Hessenberg matrix 
    g    ::Vector{TP}  # Coefficients of the poly in the Arnoldi basis
    deg  ::Integer     # Degree of the polynomial
end</code></pre><p>A structure that describes the Arnoldi-based polynomial preconditioner.  Computing such a polynomial from a matrix <span>$A$</span>, a right-hand side <span>$b$</span>, and  a given degree can be done with the method <a href="preconditioners.html#XGMRES.polynomial"><code>polynomial</code></a>. The  application of the polynomial to a vector is available through  <a href="preconditioners.html#Base.:*"><code>Base.:*</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/polynomial.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XGMRES.polynomial" href="#XGMRES.polynomial"><code>XGMRES.polynomial</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ùëÉ::Poly = polynomial(
    A    ::AbstractMatrix{TA},
    b    ::AbstractVector{TB},
    deg  ::Integer
) where {TA&lt;:AbstractFloat,TB&lt;:AbstractFloat}</code></pre><p>Computation of an Arnoldi-based polynomial preconditioner for the matrix <span>$A$</span>. The floating point arithmetic <span>$u$</span> at which the computation is performed is the  arithmetic of the elements of <code>A</code>; if <code>b</code> is not provided in this arithmetic,  it is casted in precision u‚Çì. This implementation is based on the pseudo-code  proposed in the article <em>&quot;Polynomial Preconditioned GMRES and GMRES-DR&quot;</em><sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><p><img src="assets/polynomial.png" alt="poly_img"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/polynomial.jl#L45-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*" href="#Base.:*"><code>Base.:*</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">y::AbstractVector = (*)(
    ùëÉ   ::Poly{TP},           # Polynomial
    v   ::AbstractVector{TV}  # Vector
) where {TP&lt;:AbstractFloat,TM&lt;:AbstractFloat,TV&lt;:AbstractFloat}</code></pre><p>Application of an Arnoldi-based polynomial to a vector <span>$p(A) \times v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bvieuble/XGMRES.jl/blob/9254722b87b48776169c04f879a0f6c464008e1a/src/polynomial.jl#L116-L124">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Only useable when the problems are generated with    <a href="auxiliary.html#XGMRES.gen_mat_with_prec"><code>gen_mat_with_prec</code></a>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Erin Carson &amp; Noaman Khan, <em>&quot;Mixed Precision Iterative Refinement with    Sparse Approximate Inverse Preconditioning&quot;</em>, SIAM Journal on Scientific    Computing, <strong>(2023)</strong>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Quan Liu, Ronald B. Morgan, and Walter Wilcox, <em>&quot;Polynomial    Preconditioned GMRES and GMRES-DR&quot;</em>, SIAM Journal on Scientific    Computing, <strong>(2015)</strong>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="xgmres.html">¬´ XGMRES</a><a class="docs-footer-nextpage" href="auxiliary.html">Auxiliary Functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 8 January 2025 10:44">Wednesday 8 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
